diff '--color=auto' -Nur a/lxqt-config-appearance/configothertoolkits.cpp b/lxqt-config-appearance/configothertoolkits.cpp
--- a/lxqt-config-appearance/configothertoolkits.cpp	2025-04-17 10:06:55.000000000 +0100
+++ b/lxqt-config-appearance/configothertoolkits.cpp	2025-05-01 02:30:30.145317762 +0100
@@ -96,7 +96,7 @@
  * GTK just doesn't intend to support image menu items. They're considered bad practice in modern UI.
  */
 
-ConfigOtherToolKits::ConfigOtherToolKits(LXQt::Settings *settings, LXQt::Settings *configAppearanceSettings, QObject *parent) : QObject(parent)
+ConfigOtherToolKits::ConfigOtherToolKits(LXQt::Settings *settings,  LXQt::Settings *configAppearanceSettings, QObject *parent) : QObject(parent)
 {
     mSettings = settings;
     mConfigAppearanceSettings = configAppearanceSettings;
@@ -406,7 +406,7 @@
     if(defaultTheme.size() <= 1)
         return QString();
     // The theme has got quotation marks. Remove it:
-    defaultTheme.replace("'", "");
+    defaultTheme.replace("'","");
     return QString::fromUtf8(defaultTheme);
 }
 
diff '--color=auto' -Nur a/lxqt-config-appearance/iconthemeconfig.cpp b/lxqt-config-appearance/iconthemeconfig.cpp
--- a/lxqt-config-appearance/iconthemeconfig.cpp	2025-04-17 10:06:55.000000000 +0100
+++ b/lxqt-config-appearance/iconthemeconfig.cpp	2025-05-01 02:30:30.145317762 +0100
@@ -77,7 +77,7 @@
                 if (theme.isValid() && (!theme.isHidden()))
                 {
                     QTreeWidgetItem *item = new QTreeWidgetItem((QTreeWidget*)nullptr);
-                    item->setSizeHint(0, QSize(42, 42)); // make icons non-cropped
+                    item->setSizeHint(0, QSize(42,42)); // make icons non-cropped
                     item->setData(0, Qt::UserRole, theme.name());
 
                     const QList<QIcon> icons = theme.icons(iconNames);
diff '--color=auto' -Nur a/lxqt-config-appearance/lxqtthemeconfig.cpp b/lxqt-config-appearance/lxqtthemeconfig.cpp
--- a/lxqt-config-appearance/lxqtthemeconfig.cpp	2025-04-17 10:06:55.000000000 +0100
+++ b/lxqt-config-appearance/lxqtthemeconfig.cpp	2025-05-01 02:30:30.145317762 +0100
@@ -87,7 +87,7 @@
         {
             item->setIcon(0, QIcon(theme.previewImage()));
         }
-        item->setSizeHint(0, QSize(42, 42)); // make icons non-cropped
+        item->setSizeHint(0, QSize(42,42)); // make icons non-cropped
         item->setData(0, Qt::UserRole, theme.name());
         ui->lxqtThemeList->addTopLevelItem(item);
     }
diff '--color=auto' -Nur a/lxqt-config-appearance/styleconfig.cpp b/lxqt-config-appearance/styleconfig.cpp
--- a/lxqt-config-appearance/styleconfig.cpp	2025-04-17 10:06:55.000000000 +0100
+++ b/lxqt-config-appearance/styleconfig.cpp	2025-05-01 02:30:30.145317762 +0100
@@ -72,17 +72,17 @@
         QColor winColor(239, 239, 239);
         QPalette defaultPalette(winColor);
         ui->winColorLabel->setColor(winColor, true);
-        ui->baseColorLabel->setColor(defaultPalette.color(QPalette::Active, QPalette::Base), true);
+        ui->baseColorLabel->setColor(defaultPalette.color(QPalette::Active,QPalette::Base), true);
         // Qt's default highlight color may be different from that of Fusion
         ui->highlightColorLabel->setColor(QColor(60, 140, 230), true);
-        ui->windowTextColorLabel->setColor(defaultPalette.color(QPalette::Active, QPalette::WindowText), true);
-        ui->viewTextColorLabel->setColor(defaultPalette.color(QPalette::Active, QPalette::Text), true);
-        ui->highlightedTextColorLabel->setColor(defaultPalette.color(QPalette::Active, QPalette::HighlightedText), true);
-        ui->linkColorLabel->setColor(defaultPalette.color(QPalette::Active, QPalette::Link), true);
-        ui->linkVisitedColorLabel->setColor(defaultPalette.color(QPalette::Active, QPalette::LinkVisited), true);
+        ui->windowTextColorLabel->setColor(defaultPalette.color(QPalette::Active,QPalette::WindowText), true);
+        ui->viewTextColorLabel->setColor(defaultPalette.color(QPalette::Active,QPalette::Text), true);
+        ui->highlightedTextColorLabel->setColor(defaultPalette.color(QPalette::Active,QPalette::HighlightedText), true);
+        ui->linkColorLabel->setColor(defaultPalette.color(QPalette::Active,QPalette::Link), true);
+        ui->linkVisitedColorLabel->setColor(defaultPalette.color(QPalette::Active,QPalette::LinkVisited), true);
         // tooltips use the Inactive color group
-        ui->tooltipColorLabel->setColor(defaultPalette.color(QPalette::Inactive, QPalette::ToolTipBase), true);
-        ui->tooltipTextColorLabel->setColor(defaultPalette.color(QPalette::Inactive, QPalette::ToolTipText), true);
+        ui->tooltipColorLabel->setColor(defaultPalette.color(QPalette::Inactive,QPalette::ToolTipBase), true);
+        ui->tooltipTextColorLabel->setColor(defaultPalette.color(QPalette::Inactive,QPalette::ToolTipText), true);
     });
 
     connect(ui->savePaletteBtn, &QAbstractButton::clicked, this, &StyleConfig::savePalette);
@@ -155,53 +155,53 @@
     QColor color;
     color = QColor::fromString(mSettings->value(QStringLiteral("window_color")).toString());
     if (!color.isValid())
-        color = QGuiApplication::palette().color(QPalette::Active, QPalette::Window);
+        color = QGuiApplication::palette().color(QPalette::Active,QPalette::Window);
     ui->winColorLabel->setColor(color);
 
     color = QColor::fromString(mSettings->value(QStringLiteral("base_color")).toString());
     if (!color.isValid())
-        color = QGuiApplication::palette().color(QPalette::Active, QPalette::Base);
+        color = QGuiApplication::palette().color(QPalette::Active,QPalette::Base);
     ui->baseColorLabel->setColor(color);
 
     color = QColor::fromString(mSettings->value(QStringLiteral("highlight_color")).toString());
     if (!color.isValid())
-        color = QGuiApplication::palette().color(QPalette::Active, QPalette::Highlight);
+        color = QGuiApplication::palette().color(QPalette::Active,QPalette::Highlight);
     ui->highlightColorLabel->setColor(color);
 
     color = QColor::fromString(mSettings->value(QStringLiteral("window_text_color")).toString());
     if (!color.isValid())
-        color = QGuiApplication::palette().color(QPalette::Active, QPalette::WindowText);
+        color = QGuiApplication::palette().color(QPalette::Active,QPalette::WindowText);
     ui->windowTextColorLabel->setColor(color);
 
     color = QColor::fromString(mSettings->value(QStringLiteral("text_color")).toString());
     if (!color.isValid())
-        color = QGuiApplication::palette().color(QPalette::Active, QPalette::Text);
+        color = QGuiApplication::palette().color(QPalette::Active,QPalette::Text);
     ui->viewTextColorLabel->setColor(color);
 
     color = QColor::fromString(mSettings->value(QStringLiteral("highlighted_text_color")).toString());
     if (!color.isValid())
-        color = QGuiApplication::palette().color(QPalette::Active, QPalette::HighlightedText);
+        color = QGuiApplication::palette().color(QPalette::Active,QPalette::HighlightedText);
     ui->highlightedTextColorLabel->setColor(color);
 
     color = QColor::fromString(mSettings->value(QStringLiteral("link_color")).toString());
     if (!color.isValid())
-        color = QGuiApplication::palette().color(QPalette::Active, QPalette::Link);
+        color = QGuiApplication::palette().color(QPalette::Active,QPalette::Link);
     ui->linkColorLabel->setColor(color);
 
     color = QColor::fromString(mSettings->value(QStringLiteral("link_visited_color")).toString());
     if (!color.isValid())
-        color = QGuiApplication::palette().color(QPalette::Active, QPalette::LinkVisited);
+        color = QGuiApplication::palette().color(QPalette::Active,QPalette::LinkVisited);
     ui->linkVisitedColorLabel->setColor(color);
 
     // tooltips use the Inactive color group
     color = QColor::fromString(mSettings->value(QStringLiteral("tooltip_base_color")).toString());
     if (!color.isValid())
-        color = QGuiApplication::palette().color(QPalette::Inactive, QPalette::ToolTipBase);
+        color = QGuiApplication::palette().color(QPalette::Inactive,QPalette::ToolTipBase);
     ui->tooltipColorLabel->setColor(color);
 
     color = QColor::fromString(mSettings->value(QStringLiteral("tooltip_text_color")).toString());
     if (!color.isValid())
-        color = QGuiApplication::palette().color(QPalette::Inactive, QPalette::ToolTipText);
+        color = QGuiApplication::palette().color(QPalette::Inactive,QPalette::ToolTipText);
     ui->tooltipTextColorLabel->setColor(color);
 
     mSettings->endGroup();
@@ -438,7 +438,7 @@
                 {
                     bool visible(item->text().contains(filterStr, Qt::CaseInsensitive));
                     if (I < 0 && visible)
-                        I = i;
+                        I  = i;
                     item->setHidden(!visible);
                 }
             }
@@ -501,53 +501,53 @@
     QColor color;
     color = QColor::fromString(settings.value(QStringLiteral("window_color")).toString());
     if (!color.isValid())
-        color = QGuiApplication::palette().color(QPalette::Active, QPalette::Window);
+        color = QGuiApplication::palette().color(QPalette::Active,QPalette::Window);
     ui->winColorLabel->setColor(color, true);
 
     color = QColor::fromString(settings.value(QStringLiteral("base_color")).toString());
     if (!color.isValid())
-        color = QGuiApplication::palette().color(QPalette::Active, QPalette::Base);
+        color = QGuiApplication::palette().color(QPalette::Active,QPalette::Base);
     ui->baseColorLabel->setColor(color, true);
 
     color = QColor::fromString(settings.value(QStringLiteral("highlight_color")).toString());
     if (!color.isValid())
-        color = QGuiApplication::palette().color(QPalette::Active, QPalette::Highlight);
+        color = QGuiApplication::palette().color(QPalette::Active,QPalette::Highlight);
     ui->highlightColorLabel->setColor(color, true);
 
     color = QColor::fromString(settings.value(QStringLiteral("window_text_color")).toString());
     if (!color.isValid())
-        color = QGuiApplication::palette().color(QPalette::Active, QPalette::WindowText);
+        color = QGuiApplication::palette().color(QPalette::Active,QPalette::WindowText);
     ui->windowTextColorLabel->setColor(color, true);
 
     color = QColor::fromString(settings.value(QStringLiteral("text_color")).toString());
     if (!color.isValid())
-        color = QGuiApplication::palette().color(QPalette::Active, QPalette::Text);
+        color = QGuiApplication::palette().color(QPalette::Active,QPalette::Text);
     ui->viewTextColorLabel->setColor(color, true);
 
     color = QColor::fromString(settings.value(QStringLiteral("highlighted_text_color")).toString());
     if (!color.isValid())
-        color = QGuiApplication::palette().color(QPalette::Active, QPalette::HighlightedText);
+        color = QGuiApplication::palette().color(QPalette::Active,QPalette::HighlightedText);
     ui->highlightedTextColorLabel->setColor(color, true);
 
     color = QColor::fromString(settings.value(QStringLiteral("link_color")).toString());
     if (!color.isValid())
-        color = QGuiApplication::palette().color(QPalette::Active, QPalette::Link);
+        color = QGuiApplication::palette().color(QPalette::Active,QPalette::Link);
     ui->linkColorLabel->setColor(color, true);
 
     color = QColor::fromString(settings.value(QStringLiteral("link_visited_color")).toString());
     if (!color.isValid())
-        color = QGuiApplication::palette().color(QPalette::Active, QPalette::LinkVisited);
+        color = QGuiApplication::palette().color(QPalette::Active,QPalette::LinkVisited);
     ui->linkVisitedColorLabel->setColor(color, true);
 
     // tooltips use the Inactive color group
     color = QColor::fromString(settings.value(QStringLiteral("tooltip_base_color")).toString());
     if (!color.isValid())
-        color = QGuiApplication::palette().color(QPalette::Inactive, QPalette::ToolTipBase);
+        color = QGuiApplication::palette().color(QPalette::Inactive,QPalette::ToolTipBase);
     ui->tooltipColorLabel->setColor(color, true);
 
     color = QColor::fromString(settings.value(QStringLiteral("tooltip_text_color")).toString());
     if (!color.isValid())
-        color = QGuiApplication::palette().color(QPalette::Inactive, QPalette::ToolTipText);
+        color = QGuiApplication::palette().color(QPalette::Inactive,QPalette::ToolTipText);
     ui->tooltipTextColorLabel->setColor(color, true);
 
     settings.endGroup();
diff '--color=auto' -Nur a/lxqt-config-brightness/brightnesssettings.cpp b/lxqt-config-brightness/brightnesssettings.cpp
--- a/lxqt-config-brightness/brightnesssettings.cpp	2025-04-17 10:06:55.000000000 +0100
+++ b/lxqt-config-brightness/brightnesssettings.cpp	2025-05-01 02:30:30.146317762 +0100
@@ -97,7 +97,7 @@
 
 void BrightnessSettings::monitorSettingsChanged(MonitorInfo monitor)
 {
-    mBrightness->setMonitorsSettings(QList<MonitorInfo>{} << monitor);
+    mBrightness->setMonitorsSettings(QList<MonitorInfo>{}  << monitor);
     if (ui->confirmCB->isChecked())
         mConfirmRequestTimer.start();
     else {
diff '--color=auto' -Nur a/lxqt-config-brightness/brightnesssettings.cpp.orig b/lxqt-config-brightness/brightnesssettings.cpp.orig
--- a/lxqt-config-brightness/brightnesssettings.cpp.orig	1970-01-01 01:00:00.000000000 +0100
+++ b/lxqt-config-brightness/brightnesssettings.cpp.orig	2025-04-17 10:06:55.000000000 +0100
@@ -0,0 +1,196 @@
+/*
+    Copyright (C) 2016  P.L. Lucas <selairi@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#include "brightnesssettings.h"
+#include "outputwidget.h"
+#include <QMessageBox>
+#include <QPushButton>
+
+#include <cmath>
+#include <algorithm>
+
+BrightnessSettings::BrightnessSettings(QWidget *parent):QDialog(parent)
+{
+    ui = new Ui::BrightnessSettings();
+    ui->setupUi(this);
+
+    mBrightness = new XRandrBrightness();
+    mMonitors = mBrightness->getMonitorsInfo();
+    mMonitorsInitial = mBrightness->getMonitorsInfo();
+    mBacklight = new LXQt::Backlight(this);
+
+    ui->headIconLabel->setPixmap(QIcon::fromTheme(QStringLiteral("display-brightness-symbolic")).pixmap(32, 32));
+
+    ui->backlightSlider->setEnabled(mBacklight->isBacklightAvailable() || mBacklight->isBacklightOff());
+    ui->backlightGroupBox->setEnabled(mBacklight->isBacklightAvailable() || mBacklight->isBacklightOff());
+    if(mBacklight->isBacklightAvailable()) {
+        setBacklightSliderValue(mBacklight->getBacklight());
+
+        mInitialBacklightValue = mLastBacklightValue = mBacklight->getBacklight();
+        connect(ui->backlightSlider, &QSlider::valueChanged, this, &BrightnessSettings::setBacklight);
+
+        connect(ui->backlightDownButton, &QToolButton::clicked,
+            [this](bool){ ui->backlightSlider->setValue(ui->backlightSlider->value()-1); });
+        connect(ui->backlightUpButton, &QToolButton::clicked,
+            [this](bool){ ui->backlightSlider->setValue(ui->backlightSlider->value()+1); });
+    }
+
+    for(const MonitorInfo &monitor: std::as_const(mMonitors))
+    {
+        OutputWidget *output = new OutputWidget(monitor, this);
+        ui->layout->addWidget(output);
+        output->show();
+        connect(output, &OutputWidget::changed, this, &BrightnessSettings::monitorSettingsChanged);
+        connect(this, &BrightnessSettings::monitorReverted, output, &OutputWidget::setRevertedValues);
+    }
+
+    mConfirmRequestTimer.setSingleShot(true);
+    mConfirmRequestTimer.setInterval(1000);
+    connect(&mConfirmRequestTimer, &QTimer::timeout, this, &BrightnessSettings::requestConfirmation);
+
+    connect(ui->buttonBox, &QDialogButtonBox::clicked,
+        [this](QAbstractButton *button) {
+            if(ui->buttonBox->button(QDialogButtonBox::Reset) == button) {
+                revertValues();
+            }
+        } );
+}
+
+BrightnessSettings::~BrightnessSettings()
+{
+    delete ui;
+    ui = nullptr;
+
+    delete mBrightness;
+    mBrightness = nullptr;
+}
+
+void BrightnessSettings::setBacklight()
+{
+    int value = ui->backlightSlider->value();
+    // Set the minimum to 5% of the maximum to prevent a black screen
+    int minBacklight = std::max(std::round((qreal)(mBacklight->getMaxBacklight())*0.05), 1.0);
+    int maxBacklight = mBacklight->getMaxBacklight();
+    int interval = maxBacklight - minBacklight;
+    if(interval > 100)
+        value = (value * maxBacklight) / 100;
+    mBacklight->setBacklight(value);
+
+    if (ui->confirmCB->isChecked())
+        mConfirmRequestTimer.start();
+}
+
+void BrightnessSettings::monitorSettingsChanged(MonitorInfo monitor)
+{
+    mBrightness->setMonitorsSettings(QList<MonitorInfo>{} << monitor);
+    if (ui->confirmCB->isChecked())
+        mConfirmRequestTimer.start();
+    else {
+        for (auto & m : mMonitors) {
+            if (m.id() == monitor.id() && m.name() == monitor.name()) {
+                m.setBacklight(monitor.backlight());
+                m.setBrightness(monitor.brightness());
+            }
+        }
+    }
+}
+
+void BrightnessSettings::requestConfirmation()
+{
+    QMessageBox msg{QMessageBox::Question, tr("Brightness settings changed")
+        , tr("Confirmation required. Are the settings correct?")
+        , QMessageBox::Yes | QMessageBox::No};
+    int timeout = 5; // seconds
+    QString no_text;
+    if (auto btn = msg.button(QMessageBox::No)) {
+        no_text = btn->text();
+        no_text += QStringLiteral("(%1)");
+        btn->setText(no_text.arg(timeout));
+    }
+    msg.setDefaultButton(QMessageBox::No);
+
+    QTimer timeoutTimer;
+    timeoutTimer.setSingleShot(false);
+    timeoutTimer.setInterval(1000);
+    connect(&timeoutTimer, &QTimer::timeout, [&] {
+        if (auto btn = msg.button(QMessageBox::No)) {
+            btn->setText(no_text.arg(--timeout));
+        }
+        if (timeout == 0)
+        {
+            timeoutTimer.stop();
+            msg.reject();
+        }
+    });
+    timeoutTimer.start();
+
+    if (QMessageBox::Yes == msg.exec())
+    {
+        // re-read current values
+        if(mBacklight->isBacklightAvailable())
+            mLastBacklightValue = mBacklight->getBacklight();
+
+        mMonitors = mBrightness->getMonitorsInfo();
+    } else
+    {
+        // revert the changes
+        if(mBacklight->isBacklightAvailable()) {
+            disconnect(ui->backlightSlider, &QSlider::valueChanged, this, &BrightnessSettings::setBacklight);
+                mBacklight->setBacklight(mLastBacklightValue);
+                setBacklightSliderValue(mLastBacklightValue);
+            connect(ui->backlightSlider, &QSlider::valueChanged, this, &BrightnessSettings::setBacklight);
+        }
+
+        mBrightness->setMonitorsSettings(mMonitors);
+        for (const auto & monitor : std::as_const(mMonitors))
+            emit monitorReverted(monitor);
+    }
+}
+
+void BrightnessSettings::revertValues()
+{
+    if(mBacklight->isBacklightAvailable()) {
+        disconnect(ui->backlightSlider, &QSlider::valueChanged, this, &BrightnessSettings::setBacklight);
+            mBacklight->setBacklight(mInitialBacklightValue);
+            setBacklightSliderValue(mInitialBacklightValue);
+        connect(ui->backlightSlider, &QSlider::valueChanged, this, &BrightnessSettings::setBacklight);
+    }
+
+    mBrightness->setMonitorsSettings(mMonitorsInitial);
+    for (const auto & monitor : std::as_const(mMonitorsInitial))
+            emit monitorReverted(monitor);
+}
+
+
+void BrightnessSettings::setBacklightSliderValue(int value)
+{
+    // Set the minimum to 5% of the maximum to prevent a black screen
+    int minBacklight = std::max(std::round((qreal)(mBacklight->getMaxBacklight())*0.05), 1.0);
+    int maxBacklight = mBacklight->getMaxBacklight();
+    int interval = maxBacklight - minBacklight;
+    if(interval <= 100) {
+        ui->backlightSlider->setMaximum(maxBacklight);
+        ui->backlightSlider->setMinimum(minBacklight);
+        ui->backlightSlider->setValue(value);
+    } else {
+        ui->backlightSlider->setMaximum(100);
+        // Set the minimum to 5% of the maximum to prevent a black screen
+        ui->backlightSlider->setMinimum(5);
+        ui->backlightSlider->setValue( (value * 100) / maxBacklight);
+    }
+}
diff '--color=auto' -Nur a/lxqt-config-brightness/xrandrbrightness.cpp b/lxqt-config-brightness/xrandrbrightness.cpp
--- a/lxqt-config-brightness/xrandrbrightness.cpp	2025-04-17 10:06:55.000000000 +0100
+++ b/lxqt-config-brightness/xrandrbrightness.cpp	2025-05-01 02:30:30.146317762 +0100
@@ -160,7 +160,7 @@
         return -1;
     }
 
-    xcb_generic_error_t *error;
+    xcb_generic_error_t  *error;
 
     xcb_randr_get_output_info_cookie_t output_info_cookie = xcb_randr_get_output_info (x11NativeInterface->connection(), output, 0);
     ScopedCPointer<xcb_randr_get_output_info_reply_t> output_info(xcb_randr_get_output_info_reply (x11NativeInterface->connection(), output_info_cookie, &error));
@@ -219,7 +219,7 @@
         return;
     }
 
-    xcb_generic_error_t *error;
+    xcb_generic_error_t  *error;
 
     xcb_randr_get_output_info_cookie_t output_info_cookie = xcb_randr_get_output_info (x11NativeInterface->connection(), output, 0);
     ScopedCPointer<xcb_randr_get_output_info_reply_t> output_info(xcb_randr_get_output_info_reply (x11NativeInterface->connection(), output_info_cookie, &error));
@@ -292,7 +292,7 @@
     for (int i = 0; i < m_resources->num_outputs; ++i) {
         xcb_randr_output_t output = outputs[i];
 
-        xcb_generic_error_t *error;
+        xcb_generic_error_t  *error;
 
         xcb_randr_get_output_info_cookie_t output_info_cookie = xcb_randr_get_output_info (x11NativeInterface->connection(), output, 0);
         ScopedCPointer <xcb_randr_get_output_info_reply_t> output_info(xcb_randr_get_output_info_reply (x11NativeInterface->connection(), output_info_cookie, &error));
@@ -385,7 +385,7 @@
     for (int i = 0; i < m_resources->num_outputs; ++i) {
         xcb_randr_output_t output = outputs[i];
 
-        xcb_generic_error_t *error;
+        xcb_generic_error_t  *error;
 
         xcb_randr_get_output_info_cookie_t output_info_cookie = xcb_randr_get_output_info (x11NativeInterface->connection(), output, 0);
         ScopedCPointer<xcb_randr_get_output_info_reply_t> output_info(xcb_randr_get_output_info_reply (x11NativeInterface->connection(), output_info_cookie, &error));
diff '--color=auto' -Nur a/lxqt-config-brightness/xrandrbrightness.cpp.orig b/lxqt-config-brightness/xrandrbrightness.cpp.orig
--- a/lxqt-config-brightness/xrandrbrightness.cpp.orig	1970-01-01 01:00:00.000000000 +0100
+++ b/lxqt-config-brightness/xrandrbrightness.cpp.orig	2025-04-17 10:06:55.000000000 +0100
@@ -0,0 +1,448 @@
+/*  This file is part of the KDE project
+ *    Copyright (C) 2010 Lukas Tinkl <ltinkl@redhat.com>
+ *    Copyright (C) 2015 Kai Uwe Broulik <kde@privat.broulik.de>
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Library General Public
+ *    License version 2 as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Library General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Library General Public License
+ *    along with this library; see the file COPYING.LIB.  If not, write to
+ *    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *    Boston, MA 02110-1301, USA.
+ *
+ */
+
+
+#include <QGuiApplication>
+#include <QDebug>
+
+#include <algorithm>
+
+#include "xrandrbrightness.h"
+
+XRandrBrightness::XRandrBrightness()
+{
+    if (QGuiApplication::platformName() != QStringLiteral("xcb")) {
+        return;
+    }
+    auto x11NativeInterface = qGuiApp->nativeInterface<QNativeInterface::QX11Application>();
+    if (!x11NativeInterface) {
+        return;
+    }
+    ScopedCPointer<xcb_randr_query_version_reply_t> versionReply(xcb_randr_query_version_reply(x11NativeInterface->connection(),
+        xcb_randr_query_version(x11NativeInterface->connection(), 1, 2),
+    nullptr));
+
+    if (!versionReply) {
+        qDebug() << "RandR Query version returned null";
+        return;
+    }
+
+    if (versionReply->major_version < 1 || (versionReply->major_version == 1 && versionReply->minor_version < 2)) {
+        qDebug() << "RandR version" << versionReply->major_version << "." << versionReply->minor_version << " too old";
+        return;
+    }
+    ScopedCPointer<xcb_intern_atom_reply_t> backlightReply(xcb_intern_atom_reply(x11NativeInterface->connection(),
+        xcb_intern_atom (x11NativeInterface->connection(), 1, strlen("Backlight"), "Backlight"),
+    nullptr));
+
+    if (!backlightReply) {
+        qDebug() << "Intern Atom for Backlight returned null";
+        return;
+    }
+
+    m_backlight = backlightReply->atom;
+
+    if (m_backlight == XCB_NONE) {
+        qDebug() << "No outputs have backlight property";
+        //return;
+    }
+    xcb_screen_iterator_t iter = xcb_setup_roots_iterator(xcb_get_setup(x11NativeInterface->connection()));
+    if (!iter.rem) {
+        qDebug() << "XCB Screen Roots Iterator rem was null";
+        return;
+    }
+
+    xcb_screen_t *screen = iter.data;
+    xcb_window_t root = screen->root;
+
+    m_resources.reset(xcb_randr_get_screen_resources_current_reply(x11NativeInterface->connection(),
+        xcb_randr_get_screen_resources_current(x11NativeInterface->connection(), root)
+    , nullptr));
+
+    if (!m_resources) {
+        qDebug() << "RANDR Get Screen Resources returned null";
+        return;
+    }
+}
+
+
+
+bool XRandrBrightness::backlight_get_with_range(xcb_randr_output_t output, long &value, long &min, long &max) const {
+    long cur = backlight_get(output);
+    if (cur == -1) {
+       return false;
+    }
+    auto x11NativeInterface = qGuiApp->nativeInterface<QNativeInterface::QX11Application>();
+    if (!x11NativeInterface) {
+        return false;
+    }
+
+    ScopedCPointer<xcb_randr_query_output_property_reply_t> propertyReply(xcb_randr_query_output_property_reply(x11NativeInterface->connection(),
+        xcb_randr_query_output_property(x11NativeInterface->connection(), output, m_backlight)
+    , nullptr));
+
+    if (!propertyReply) {
+        return false;
+    }
+
+    if (propertyReply->range && xcb_randr_query_output_property_valid_values_length(propertyReply.data()) == 2) {
+        int32_t *values = xcb_randr_query_output_property_valid_values(propertyReply.data());
+        value = cur;
+        min = values[0];
+        max = values[1];
+        return true;
+    }
+
+    return false;
+}
+
+long XRandrBrightness::backlight_get(xcb_randr_output_t output) const
+{
+    auto x11NativeInterface = qGuiApp->nativeInterface<QNativeInterface::QX11Application>();
+    if (!x11NativeInterface) {
+        return -1;
+    }
+
+    ScopedCPointer<xcb_randr_get_output_property_reply_t> propertyReply;
+    long value;
+
+    if (m_backlight != XCB_ATOM_NONE) {
+        propertyReply.reset(xcb_randr_get_output_property_reply(x11NativeInterface->connection(),
+            xcb_randr_get_output_property(x11NativeInterface->connection(), output, m_backlight, XCB_ATOM_NONE, 0, 4, 0, 0)
+        , nullptr));
+
+        if (!propertyReply) {
+            return -1;
+        }
+    }
+
+    if (!propertyReply || propertyReply->type != XCB_ATOM_INTEGER || propertyReply->num_items != 1 || propertyReply->format != 32) {
+        value = -1;
+    } else {
+        value = *(reinterpret_cast<long *>(xcb_randr_get_output_property_data(propertyReply.data())));
+    }
+    return value;
+}
+
+void XRandrBrightness::backlight_set(xcb_randr_output_t output, long value)
+{
+    auto x11NativeInterface = qGuiApp->nativeInterface<QNativeInterface::QX11Application>();
+    if (!x11NativeInterface) {
+        return;
+    }
+    xcb_randr_change_output_property(x11NativeInterface->connection(), output, m_backlight, XCB_ATOM_INTEGER,
+                                     32, XCB_PROP_MODE_REPLACE,
+                                     1, reinterpret_cast<unsigned char *>(&value));
+}
+
+
+float XRandrBrightness::gamma_brightness_get(xcb_randr_output_t output)
+{
+    auto x11NativeInterface = qGuiApp->nativeInterface<QNativeInterface::QX11Application>();
+    if (!x11NativeInterface) {
+        return -1;
+    }
+
+    xcb_generic_error_t *error;
+
+    xcb_randr_get_output_info_cookie_t output_info_cookie = xcb_randr_get_output_info (x11NativeInterface->connection(), output, 0);
+    ScopedCPointer<xcb_randr_get_output_info_reply_t> output_info(xcb_randr_get_output_info_reply (x11NativeInterface->connection(), output_info_cookie, &error));
+    if(error != nullptr)
+    {
+        qDebug() << "Error getting output_info";
+        return -1;
+    }
+    if(output_info == nullptr)
+    {
+        qDebug() << "Error: output_info is null";
+        return -1;
+    }
+    // xcb_randr_get_output_info_reply_t tiene como elemento crtc
+    xcb_randr_get_crtc_gamma_cookie_t gamma_cookie = xcb_randr_get_crtc_gamma_unchecked (x11NativeInterface->connection(), output_info->crtc);
+    ScopedCPointer<xcb_randr_get_crtc_gamma_reply_t> gamma_reply(xcb_randr_get_crtc_gamma_reply (x11NativeInterface->connection(), gamma_cookie, &error));
+    if(error != nullptr)
+    {
+        qDebug() << "Error getting gamma_reply";
+        return -1;
+    }
+    if(gamma_reply == nullptr)
+    {
+        qDebug() << "Error: gamma_reply is null";
+        return -1;
+    }
+    uint16_t * red = xcb_randr_get_crtc_gamma_red (gamma_reply.data());
+    if(red == nullptr)
+    {
+        qDebug() << "Error: red is null";
+        return -1;
+    }
+    int red_length = xcb_randr_get_crtc_gamma_red_length(gamma_reply.data());
+
+    // uint16_t *green = xcb_randr_get_crtc_gamma_green (gamma_reply);
+    // if(green == NULL)
+    // {
+    //     qDebug() << "Error: green is null";
+    //     return -1;
+    // }
+    // uint16_t *blue = xcb_randr_get_crtc_gamma_blue (gamma_reply);
+    // if(blue == NULL)
+    // {
+    //     qDebug() << "Error: blue is null";
+    //     return -1;
+    // }
+
+    float brightness = (float)red[red_length-1]/65535.0;
+    return brightness;
+}
+
+void XRandrBrightness::gamma_brightness_set(xcb_randr_output_t output, float percent)
+{
+    auto x11NativeInterface = qGuiApp->nativeInterface<QNativeInterface::QX11Application>();
+    if (!x11NativeInterface) {
+        return;
+    }
+
+    xcb_generic_error_t *error;
+
+    xcb_randr_get_output_info_cookie_t output_info_cookie = xcb_randr_get_output_info (x11NativeInterface->connection(), output, 0);
+    ScopedCPointer<xcb_randr_get_output_info_reply_t> output_info(xcb_randr_get_output_info_reply (x11NativeInterface->connection(), output_info_cookie, &error));
+    if(error != nullptr)
+    {
+        qDebug() << "Error getting output_info";
+        return;
+    }
+    if(output_info == nullptr)
+    {
+        qDebug() << "Error: output_info is null";
+        return;
+    }
+    // xcb_randr_get_output_info_reply_t tiene como elemento crtc
+    xcb_randr_get_crtc_gamma_cookie_t gamma_cookie = xcb_randr_get_crtc_gamma_unchecked (x11NativeInterface->connection(), output_info->crtc);
+    ScopedCPointer<xcb_randr_get_crtc_gamma_reply_t> gamma_reply(xcb_randr_get_crtc_gamma_reply (x11NativeInterface->connection(), gamma_cookie, &error));
+    if(error != nullptr)
+    {
+        qDebug() << "Error getting gamma_reply";
+        return;
+    }
+    if(gamma_reply == nullptr)
+    {
+        qDebug() << "Error: gamma_reply is null";
+        return;
+    }
+    uint16_t *red = xcb_randr_get_crtc_gamma_red (gamma_reply.data());
+    if(red == nullptr)
+    {
+        qDebug() << "Error: red is null";
+        return;
+    }
+    int red_length = xcb_randr_get_crtc_gamma_red_length(gamma_reply.data());
+    uint16_t *green = xcb_randr_get_crtc_gamma_green (gamma_reply.data());
+    if(green == nullptr)
+    {
+        qDebug() << "Error: green is null";
+        return;
+    }
+    uint16_t *blue = xcb_randr_get_crtc_gamma_blue (gamma_reply.data());
+    if(blue == nullptr)
+    {
+        qDebug() << "Error: blue is null";
+        return;
+    }
+
+    float max_gamma = 65535*percent;
+    for(int i=0;i<red_length;i++)
+    {
+        int value = std::min((int)(((float)i/(float)(red_length-1))*max_gamma), 65535);
+        green[i] = blue[i] = red[i] = value;
+    }
+    xcb_randr_set_crtc_gamma (x11NativeInterface->connection(), output_info->crtc, red_length, red, green, blue);
+}
+
+
+QList<MonitorInfo> XRandrBrightness::getMonitorsInfo()
+{
+    QList<MonitorInfo> monitors;
+
+    if (!m_resources) {
+        return monitors;
+    }
+    auto x11NativeInterface = qGuiApp->nativeInterface<QNativeInterface::QX11Application>();
+    if (!x11NativeInterface) {
+        return monitors;
+    }
+
+    auto *outputs = xcb_randr_get_screen_resources_current_outputs(m_resources.data());
+    for (int i = 0; i < m_resources->num_outputs; ++i) {
+        xcb_randr_output_t output = outputs[i];
+
+        xcb_generic_error_t *error;
+
+        xcb_randr_get_output_info_cookie_t output_info_cookie = xcb_randr_get_output_info (x11NativeInterface->connection(), output, 0);
+        ScopedCPointer <xcb_randr_get_output_info_reply_t> output_info(xcb_randr_get_output_info_reply (x11NativeInterface->connection(), output_info_cookie, &error));
+        if(error != nullptr)
+        {
+            qDebug() << "Error getting output_info";
+            continue;
+        }
+        if(output_info == nullptr)
+        {
+            qDebug() << "Error: output_info is null";
+            continue;
+        }
+
+        QString name = QString::fromUtf8((const char *) xcb_randr_get_output_info_name(output_info.data()), output_info->name_len);
+
+
+        qDebug() << "Found output:" << name;
+
+
+        // Is connected?
+        if ( (xcb_randr_connection_t)(output_info->connection) != XCB_RANDR_CONNECTION_CONNECTED )
+        {
+            qDebug() << "Output is not connected";
+            continue; // This output is not connected. Check other
+        }
+
+        // Is enabled?
+        if( output_info->crtc == 0)
+        {
+            qDebug() << "Crtc is not null. Output not enabled.";
+            continue;
+        }
+        xcb_randr_get_crtc_info_cookie_t crtc_info_cookie = xcb_randr_get_crtc_info_unchecked (x11NativeInterface->connection(), output_info->crtc, 0);
+        ScopedCPointer<xcb_randr_get_crtc_info_reply_t> crtc_info(xcb_randr_get_crtc_info_reply (x11NativeInterface->connection(), crtc_info_cookie, &error));
+        if(error != nullptr)
+        {
+            qDebug() << "Error getting output_info";
+            continue;
+        }
+        if(crtc_info == nullptr)
+        {
+            qDebug() << "Error: output_info is null";
+            continue;
+        }
+        if( crtc_info->mode == XCB_NONE )
+        {
+            qDebug() << "No modes. Output not enabled.";
+            continue;
+        }
+
+        // Output is connected and enabled. Get data:
+        bool backlightIsSupported = false;
+        long cur, min, max, backlight_max = -1;
+        if (backlight_get(output) != -1)
+        {
+            if (backlight_get_with_range(output, cur, min, max))
+            {
+                backlightIsSupported = true;
+                backlight_max = max - min;
+            }
+        }
+
+        MonitorInfo monitor((int)output, name, backlight_max);
+
+        if(backlightIsSupported)
+            monitor.setBacklight(cur-min);
+
+        monitor.setBrightness(gamma_brightness_get(output));
+
+        qDebug() << "Output:" << name << "added";
+        monitors.append(monitor);
+
+    }
+
+    return monitors;
+}
+
+void XRandrBrightness::setMonitorsSettings(QList<MonitorInfo> monitors)
+{
+    if (!m_resources) {
+        return;
+    }
+    auto x11NativeInterface = qGuiApp->nativeInterface<QNativeInterface::QX11Application>();
+    if (!x11NativeInterface) {
+        return;
+    }
+
+    auto *outputs = xcb_randr_get_screen_resources_current_outputs(m_resources.data());
+    for (int i = 0; i < m_resources->num_outputs; ++i) {
+        xcb_randr_output_t output = outputs[i];
+
+        xcb_generic_error_t *error;
+
+        xcb_randr_get_output_info_cookie_t output_info_cookie = xcb_randr_get_output_info (x11NativeInterface->connection(), output, 0);
+        ScopedCPointer<xcb_randr_get_output_info_reply_t> output_info(xcb_randr_get_output_info_reply (x11NativeInterface->connection(), output_info_cookie, &error));
+        if(error != nullptr)
+        {
+            qDebug() << "Error getting output_info";
+            continue;
+        }
+        if(output_info == nullptr)
+        {
+            qDebug() << "Error: output_info is null";
+            continue;
+        }
+
+        // Is connected?
+        if ( (xcb_randr_connection_t)(output_info->connection) != XCB_RANDR_CONNECTION_CONNECTED )
+            continue; // This output is not connected. Check other
+
+        // Is enabled?
+        if( output_info->crtc == 0)
+            continue;
+        xcb_randr_get_crtc_info_cookie_t crtc_info_cookie = xcb_randr_get_crtc_info_unchecked (x11NativeInterface->connection(), output_info->crtc, 0);
+        ScopedCPointer<xcb_randr_get_crtc_info_reply_t> crtc_info(xcb_randr_get_crtc_info_reply (x11NativeInterface->connection(), crtc_info_cookie, &error));
+        if(error != nullptr)
+            continue;
+        if(crtc_info == nullptr || crtc_info->mode == XCB_NONE )
+            continue;
+
+        QString name = QString::fromUtf8((const char *) xcb_randr_get_output_info_name(output_info.data()), output_info->name_len);
+
+        // Output is connected and enabled. Get data:
+        bool backlightIsSupported = false;
+        long cur, min, max, backlight_value = 0;
+        if (backlight_get(output) != -1)
+        {
+            if (backlight_get_with_range(output, cur, min, max))
+            {
+                backlightIsSupported = true;
+                backlight_value = cur - min;
+            }
+        }
+        float brightness_value = gamma_brightness_get(output);
+
+        // Compare output info with settings and set it.
+        for(const MonitorInfo &monitor: monitors)
+        {
+            //qDebug() << "[XRandrBrightness::setMonitorsSettings]" << monitor.id() << (int)output << monitor.name() << name ;
+            if(monitor.id() == (int)output && monitor.name() == name)
+            {
+                // Set settings
+                if(backlightIsSupported && monitor.backlight() != backlight_value)
+                    backlight_set(output, min+monitor.backlight());
+                if(monitor.brightness() != brightness_value)
+                    gamma_brightness_set(output, monitor.brightness());
+                break;
+            }
+        }
+    }
+}
+
diff '--color=auto' -Nur a/lxqt-config-file-associations/mimetypeviewer.cpp b/lxqt-config-file-associations/mimetypeviewer.cpp
--- a/lxqt-config-file-associations/mimetypeviewer.cpp	2025-04-17 10:06:55.000000000 +0100
+++ b/lxqt-config-file-associations/mimetypeviewer.cpp	2025-05-01 02:30:30.146317762 +0100
@@ -230,14 +230,14 @@
 
     widget.searchTermLineEdit->setTextMargins(0, 0, 30, 0);
     QHBoxLayout *hBoxLayout = new QHBoxLayout(widget.searchTermLineEdit);
-    hBoxLayout->setContentsMargins(0, 0, 0, 0);
+    hBoxLayout->setContentsMargins(0,0,0,0);
     widget.searchTermLineEdit->setLayout(hBoxLayout);
     QLabel *searchIconLabel = new QLabel(widget.searchTermLineEdit);
     searchIconLabel->setAlignment(Qt::AlignHCenter | Qt::AlignVCenter);
     searchIconLabel->setMinimumHeight(30);
     searchIconLabel->setMinimumWidth(30);
 
-    searchIconLabel->setPixmap(searchIcon.pixmap(QSize(20, 20)));
+    searchIconLabel->setPixmap(searchIcon.pixmap(QSize(20,20)));
     hBoxLayout->addWidget(searchIconLabel, 0, Qt::AlignRight | Qt::AlignVCenter);
 }
 
diff '--color=auto' -Nur a/lxqt-config-monitor/loadsettings.cpp b/lxqt-config-monitor/loadsettings.cpp
--- a/lxqt-config-monitor/loadsettings.cpp	2025-04-17 10:06:55.000000000 +0100
+++ b/lxqt-config-monitor/loadsettings.cpp	2025-05-01 02:30:30.146317762 +0100
@@ -61,7 +61,7 @@
 
 void LoadSettings::applyBestSettings()
 {
-    KScreen::GetConfigOperation *operation = new KScreen::GetConfigOperation();
+    KScreen::GetConfigOperation *operation  = new KScreen::GetConfigOperation();
     connect(operation, &KScreen::GetConfigOperation::finished, [this, operation] (KScreen::ConfigOperation *op) {
         KScreen::GetConfigOperation *configOp = qobject_cast<KScreen::GetConfigOperation *>(op);
         if (configOp) {
diff '--color=auto' -Nur a/lxqt-config-monitor/managesavedsettings.cpp b/lxqt-config-monitor/managesavedsettings.cpp
--- a/lxqt-config-monitor/managesavedsettings.cpp	2025-04-17 10:06:55.000000000 +0100
+++ b/lxqt-config-monitor/managesavedsettings.cpp	2025-05-01 02:30:30.146317762 +0100
@@ -29,7 +29,7 @@
 Q_DECLARE_METATYPE(MonitorSavedSettings)
 
 
-ManageSavedSettings::ManageSavedSettings(LXQt::Settings * applicationSettings, KScreen::ConfigPtr config, QWidget * parent):
+ManageSavedSettings::ManageSavedSettings(LXQt::Settings * applicationSettings,  KScreen::ConfigPtr config, QWidget * parent):
     QDialog(parent)
 {
 
diff '--color=auto' -Nur a/lxqt-config-monitor/monitorpicture.cpp b/lxqt-config-monitor/monitorpicture.cpp
--- a/lxqt-config-monitor/monitorpicture.cpp	2025-04-17 10:06:55.000000000 +0100
+++ b/lxqt-config-monitor/monitorpicture.cpp	2025-05-01 02:30:30.147317761 +0100
@@ -68,7 +68,7 @@
 }
 
 MonitorPictureDialog::MonitorPictureDialog(KScreen::ConfigPtr config, QWidget * parent, Qt::WindowFlags f) :
-    QWidget(parent, f)
+    QWidget(parent,f)
 {
     updatingOk = false;
     firstShownOk = false;
@@ -182,7 +182,7 @@
             picture->monitorWidget->ui.yPosSpinBox->setValue(y);
         //else
         //    qDebug() << "y Iguales";
-        //qDebug() << "[MonitorPictureDialog::updateMonitorWidgets]" << x << '=' << picture->monitorWidget->ui.xPosSpinBox->value() << ',' << y << '=' << picture->monitorWidget->ui.yPosSpinBox->value();
+        //qDebug() << "[MonitorPictureDialog::updateMonitorWidgets]" << x << '=' <<  picture->monitorWidget->ui.xPosSpinBox->value() << ',' << y << '=' << picture->monitorWidget->ui.yPosSpinBox->value();
     }
     updatingOk = false;
 }
diff '--color=auto' -Nur a/lxqt-config-monitor/monitorpicture.cpp.orig b/lxqt-config-monitor/monitorpicture.cpp.orig
--- a/lxqt-config-monitor/monitorpicture.cpp.orig	1970-01-01 01:00:00.000000000 +0100
+++ b/lxqt-config-monitor/monitorpicture.cpp.orig	2025-04-17 10:06:55.000000000 +0100
@@ -0,0 +1,420 @@
+/*
+ *    Copyright (C) 2014  P.L. Lucas <selairi@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include "monitorpicture.h"
+
+#include <QFont>
+#include <QFontMetrics>
+#include <QPen>
+#include <QDebug>
+#include <QVector2D>
+#include <QRectF>
+#include <KScreen/Mode>
+#include <QScrollBar>
+#include <QResizeEvent>
+#include <QTransform>
+
+#include <cmath>
+#include <algorithm>
+
+#include "configure.h"
+
+// Gets size from string rate. String rate format is "widthxheight". Example: 800x600
+static QSize sizeFromString(QString str)
+{
+    int width = 0;
+    int height = 0;
+    int x = str.indexOf(QLatin1Char('x'));
+    if (x > 0) {
+        width = str.first(x).toInt();
+        height = str.last(str.size() - x - 1).toInt();
+    }
+    return QSize(width, height);
+}
+
+MonitorPictureProxy::MonitorPictureProxy(QObject *parent, MonitorPicture *monitorPicture):QObject(parent)
+{
+    this->monitorPicture = monitorPicture;
+}
+
+void MonitorPictureProxy::updateSize()
+{
+    KScreen::OutputPtr output = monitorPicture->monitorWidget->output;
+    QSize size = output->currentMode()->size();
+    monitorPicture->updateSize(size);
+}
+
+void MonitorPictureProxy::updatePosition()
+{
+    KScreen::OutputPtr output = monitorPicture->monitorWidget->output;
+    QPoint pos = output->pos();
+    //qDebug() << "MonitorPictureProxy:updatePosition]" << pos;
+    monitorPicture->setMonitorPosition(pos.x(), pos.y());
+}
+
+MonitorPictureDialog::MonitorPictureDialog(KScreen::ConfigPtr config, QWidget * parent, Qt::WindowFlags f) :
+    QWidget(parent, f)
+{
+    updatingOk = false;
+    firstShownOk = false;
+    maxMonitorSize = 0;
+    mConfig = config;
+    ui.setupUi(this);
+}
+
+
+void MonitorPictureDialog::setScene(QList<MonitorWidget *> monitors)
+{
+    int monitorsWidth =0;
+    int monitorsHeight = 0;
+    QGraphicsScene *scene = new QGraphicsScene(this);
+    for (MonitorWidget *monitor : monitors) {
+        MonitorPicture *monitorPicture = new MonitorPicture(nullptr, monitor, this);
+        pictures.append(monitorPicture);
+        scene->addItem(monitorPicture);
+        monitorsWidth += monitorPicture->rect().width();
+        monitorsHeight += monitorPicture->rect().height();
+        MonitorPictureProxy *proxy = new MonitorPictureProxy(this, monitorPicture);
+        proxy->connect(monitor->output.data(), &KScreen::Output::currentModeIdChanged, proxy, &MonitorPictureProxy::updateSize);
+        proxy->connect(monitor->output.data(), &KScreen::Output::posChanged, proxy, &MonitorPictureProxy::updatePosition);
+    }
+    // The blue rectangle is maximum size of virtual screen (framebuffer)
+    scene->addRect(0, 0, mConfig->screen()->maxSize().width(), mConfig->screen()->maxSize().height(), QPen(Qt::blue, 20))->setOpacity(0.5);
+    maxMonitorSize = std::max(monitorsWidth, monitorsHeight);
+    ui.graphicsView->setScene(scene);
+}
+
+void MonitorPictureDialog::showEvent(QShowEvent * event)
+{
+    QWidget::showEvent(event);
+    if (!firstShownOk) {
+        firstShownOk = true;
+        qreal minWidgetLength = static_cast<qreal>(std::max(ui.graphicsView->size().width(), ui.graphicsView->size().height())) / 1.2;
+        if (maxMonitorSize > 0)
+            updateScale(minWidgetLength / maxMonitorSize);
+    }
+}
+
+void MonitorPictureDialog::resizeEvent(QResizeEvent *event)
+{
+    QWidget::resizeEvent(event);
+    if (firstShownOk && maxMonitorSize > 0)
+    {
+        qreal scale = ui.graphicsView->transform().m11();
+        if (scale > 0)
+        {
+            qreal minWidgetLength = static_cast<qreal>(std::max(ui.graphicsView->size().width(), ui.graphicsView->size().height())) / 1.2;
+            updateScale((minWidgetLength / maxMonitorSize) / scale);
+        }
+    }
+}
+
+void MonitorPictureDialog::updateScale(qreal scale)
+{
+    // Update scale and set scrollbar position.
+    if (scale > 0)
+    {
+        ui.graphicsView->scale(scale, scale);
+        updateScene();
+        ui.graphicsView->verticalScrollBar()->setValue(0);
+        ui.graphicsView->horizontalScrollBar()->setValue(0);
+    }
+}
+
+void MonitorPictureDialog::updateScene()
+{
+    ui.graphicsView->scene()->update();
+}
+
+void MonitorPictureDialog::updateMonitorWidgets(QString primaryMonitor)
+{
+    // This method update spin boxes of position.
+    // If position is changed when this method is running, position is changed until buffer overflow.
+    // updatingOk control that this method can not be run twice in the same position change.
+
+    if(updatingOk)
+        return;
+    updatingOk = true;
+    int x0, y0;
+    x0 = y0 = 0;
+
+    for (MonitorPicture *picture : std::as_const(pictures)) {
+        if (picture->monitorWidget->output->name() == primaryMonitor
+                || primaryMonitor == QLatin1String()) {
+            x0 = picture->originX + picture->pos().x();
+            y0 = picture->originY + picture->pos().y();
+            break;
+        }
+    }
+
+    if( primaryMonitor == QLatin1String() ) {
+        for(MonitorPicture *picture : std::as_const(pictures)) {
+            int x1 = picture->originX + picture->pos().x();
+            int y1 = picture->originY + picture->pos().y();
+            x0 = std::min(x0, x1);
+            y0 = std::min(y0, y1);
+        }
+    }
+
+    for (MonitorPicture *picture : std::as_const(pictures)) {
+        int x = picture->originX + picture->pos().x() - x0;
+        int y = picture->originY + picture->pos().y() - y0;
+        if( x != picture->monitorWidget->ui.xPosSpinBox->value() )
+            picture->monitorWidget->ui.xPosSpinBox->setValue(x);
+        //else
+        //    qDebug() << "x Iguales";
+        if( y != picture->monitorWidget->ui.yPosSpinBox->value() )
+            picture->monitorWidget->ui.yPosSpinBox->setValue(y);
+        //else
+        //    qDebug() << "y Iguales";
+        //qDebug() << "[MonitorPictureDialog::updateMonitorWidgets]" << x << '=' << picture->monitorWidget->ui.xPosSpinBox->value() << ',' << y << '=' << picture->monitorWidget->ui.yPosSpinBox->value();
+    }
+    updatingOk = false;
+}
+
+MonitorPicture::MonitorPicture(QGraphicsItem * parent,
+                               MonitorWidget *monitorWidget,
+                               MonitorPictureDialog *monitorPictureDialog) :
+    QGraphicsRectItem(parent)
+{
+    this->monitorWidget = monitorWidget;
+    this->monitorPictureDialog = monitorPictureDialog;
+    QSizeF currentSizeF = sizeFromString(monitorWidget->ui.resolutionCombo->currentText()) / monitorWidget->output->scale();
+    QSize currentSize = currentSizeF.toSize();
+    if( monitorWidget->output->rotation() == KScreen::Output::Left || monitorWidget->output->rotation() == KScreen::Output::Right )
+        currentSize.transpose();
+    int x = monitorWidget->ui.xPosSpinBox->value();
+    int y = monitorWidget->ui.yPosSpinBox->value();
+    setAcceptedMouseButtons(Qt::LeftButton);
+    setFlags(QGraphicsItem::ItemIsMovable | QGraphicsItem::ItemSendsGeometryChanges);
+    originX = x;
+    originY = y;
+
+    setRect(x, y, currentSize.width(), currentSize.height());
+    // setPen(QPen(Qt::black, 20));
+    // textItem = new QGraphicsTextItem(monitorWidget->output->name(), this);
+    // textItem->setX(x);
+    // textItem->setY(y);
+    // textItem->setParentItem(this);
+
+    QSvgRenderer *renderer = new QSvgRenderer(QLatin1String(ICON_PATH "monitor.svg"));
+    svgItem = new QGraphicsSvgItem();
+    svgItem->setSharedRenderer(renderer);
+    svgItem->setX(x);
+    svgItem->setY(y);
+    svgItem->setOpacity(0.7);
+    svgItem->setParentItem(this);
+
+
+    textItem = new QGraphicsTextItem(monitorWidget->output->name(), this);
+    textItem->setDefaultTextColor(Qt::white);
+    textItem->setX(x);
+    textItem->setY(y);
+    textItem->setParentItem(this);
+    setPen(QPen(Qt::black, 20));
+
+
+    adjustNameSize();
+}
+
+void MonitorPicture::adjustNameSize()
+{
+    prepareGeometryChange();
+    qreal fontWidth = QFontMetrics(textItem->font()).horizontalAdvance(monitorWidget->output->name() + QStringLiteral("  "));
+    textItem->setScale((qreal) this->rect().width() / fontWidth);
+    QTransform transform;
+    qreal width = std::abs(this->rect().width()/svgItem->boundingRect().width());
+    qreal height = std::abs(this->rect().height()/svgItem->boundingRect().height());
+    qDebug() << "Width x Height" << width << "x" << height;
+    transform.scale(width, height);
+    svgItem->setTransform(transform);
+}
+
+void MonitorPicture::updateSize(QSize currentSize)
+{
+    QRectF r = rect();
+    r.setSize(currentSize);
+    setRect(r);
+    adjustNameSize();
+}
+
+QVariant MonitorPicture::itemChange(GraphicsItemChange change, const QVariant & value)
+{
+    //qDebug() << "[MonitorPicture::itemChange]: ";
+    //if ( change == ItemPositionChange && scene()) {
+    // value is the new position.
+    //QPointF newPos = value.toPointF();
+    //qDebug() << "[MonitorPictureDialog::updateMonitorWidgets]: " << newPos.x() << "x" << newPos.y();
+    //}
+    QVariant v = QGraphicsItem::itemChange(change, value);
+    //monitorPictureDialog->updateMonitorWidgets(QString());
+    return v;
+}
+
+void MonitorPicture::setMonitorPosition(int x, int y)
+{
+    setX( x - originX );
+    setY( y - originY );
+}
+
+void MonitorPicture::mouseReleaseEvent(QGraphicsSceneMouseEvent * event)
+{
+    QGraphicsRectItem::mouseReleaseEvent(event);
+    monitorPictureDialog->moveMonitorPictureToNearest(this);
+    monitorPictureDialog->updateMonitorWidgets(QString());
+}
+
+//////////////////////////////////////////////////////////////////////////////////
+// Move picture to nearest picture procedure.
+//////////////////////////////////////////////////////////////////////////////////
+
+struct Result_moveMonitorPictureToNearest {
+    bool ok = false;
+    bool outside = false;
+    QVector2D vector;
+};
+
+static Result_moveMonitorPictureToNearest compareTwoMonitors(MonitorPicture* monitorPicture1,
+        MonitorPicture* monitorPicture2)
+{
+    Result_moveMonitorPictureToNearest result;
+    QVector2D offsetVector(0, 0);
+    QRectF extendedAreaRect;
+    QRectF monitorPicture1Rect(
+        monitorPicture1->x() + monitorPicture1->originX,
+        monitorPicture1->y() + monitorPicture1->originY,
+        monitorPicture1->rect().width(),
+        monitorPicture1->rect().height());
+    QRectF monitorPicture2Rect(
+        monitorPicture2->x() + monitorPicture2->originX,
+        monitorPicture2->y() + monitorPicture2->originY,
+        monitorPicture2->rect().width(),
+        monitorPicture2->rect().height());
+
+    if(monitorPicture1Rect.intersects(monitorPicture2Rect)) {
+        result.ok = true;
+        return result;
+    }
+
+    result.outside = true;
+    result.ok = false;
+
+    extendedAreaRect = QRectF(
+                           std::min(monitorPicture2Rect.x(), monitorPicture1Rect.x()) - monitorPicture2Rect.width(),
+                           monitorPicture2Rect.y(),
+                           std::max(monitorPicture2Rect.x(), monitorPicture1Rect.x()) + 2*monitorPicture2Rect.width(),
+                           monitorPicture2Rect.height());
+
+    //qDebug() << "\nextendedAreaRect: " << extendedAreaRect;
+    //qDebug() << "monitorPicture1Rect: " << monitorPicture1Rect << monitorPicture1->rect().width() << monitorPicture1->rect().height();
+    //qDebug() << "monitorPicture2Rect: " << monitorPicture2Rect;
+
+    if(extendedAreaRect.intersects(monitorPicture1Rect)) {
+        // monitorPicture1 left
+        offsetVector = QVector2D(monitorPicture2Rect.right() - monitorPicture1Rect.left(), 0);
+        result.vector = offsetVector;
+
+        // monitorPicture1 right
+        offsetVector = QVector2D(monitorPicture2Rect.left() - monitorPicture1Rect.right(), 0);
+        if(result.vector.length() > offsetVector.length())
+            result.vector = offsetVector;
+
+        float y2 = monitorPicture2Rect.top();
+        float y1 = monitorPicture1Rect.top();
+        float delta = monitorPicture2Rect.height() * 0.1;
+        if(y2 < y1 && y1 < (y2+delta))
+            result.vector.setY(y2 - y1);
+        else {
+            y2 = monitorPicture2Rect.bottom();
+            y1 = monitorPicture1Rect.bottom();
+            if((y2 - delta) < y1 && y1 < y2)
+                result.vector.setY(y2 - y1);
+        }
+
+        result.outside = false;
+    }
+
+    extendedAreaRect = QRectF(
+                           monitorPicture2Rect.x(),
+                           std::min(monitorPicture2Rect.y(), monitorPicture1Rect.y()) - monitorPicture2Rect.height(),
+                           monitorPicture2Rect.width(),
+                           std::max(monitorPicture2Rect.y(), monitorPicture1Rect.y()) + 2*monitorPicture2Rect.height()
+                       );
+
+    if(extendedAreaRect.intersects(monitorPicture1Rect)) {
+        // monitorPicture1 top
+        offsetVector = QVector2D(0, monitorPicture2Rect.bottom() - monitorPicture1Rect.top());
+        result.vector = offsetVector;
+
+        // monitorPicture1 bottom
+        offsetVector = QVector2D(0, monitorPicture2Rect.top() - monitorPicture1Rect.bottom());
+        if(result.vector.length() > offsetVector.length())
+            result.vector = offsetVector;
+
+        float x2 = monitorPicture2Rect.left();
+        float x1 = monitorPicture1Rect.left();
+        float delta = monitorPicture2Rect.width() * 0.1;
+        if(x2 < x1 && x1 < (x2+delta))
+            result.vector.setX(x2 - x1);
+        else {
+            x2 = monitorPicture2Rect.right();
+            x1 = monitorPicture1Rect.right();
+            if((x2 - delta) < x1 && x1 < x2)
+                result.vector.setX(x2 - x1);
+        }
+
+        result.outside = false;
+    }
+
+    return result;
+}
+
+
+void MonitorPictureDialog::moveMonitorPictureToNearest(MonitorPicture* monitorPicture)
+{
+    if (!ui.magneticCheckBox->isChecked())
+        return;
+
+    // Float to int
+    monitorPicture->setX(static_cast<qreal>(std::round(monitorPicture->x())));
+    monitorPicture->setY(static_cast<qreal>(std::round(monitorPicture->y())));
+
+
+    QVector2D vector(0, 0);
+    for (MonitorPicture *picture : std::as_const(pictures)) {
+        if (picture == monitorPicture)
+            continue;
+
+        // Float to int. The positions of the Monitors must be set with pixels.
+        // QGraphicsView uses float to store x and y. Then, positions as (800.5, 600.3) are stored.
+        // x and y have to be translated from float to int in order to store pixels position:
+        picture->setX(static_cast<qreal>(std::round(picture->x())));
+        picture->setY(static_cast<qreal>(std::round(picture->y())));
+
+        Result_moveMonitorPictureToNearest result = compareTwoMonitors(monitorPicture, picture);
+        if (result.ok)
+            return;
+        else if (! result.outside && (result.vector.length() < vector.length() || vector.length() == 0.0))
+            vector = result.vector;
+    }
+
+    int x = monitorPicture->x();
+    int y = monitorPicture->y();
+    monitorPicture->setX(x + vector.x());
+    monitorPicture->setY(y + vector.y());
+}
diff '--color=auto' -Nur a/lxqt-config-monitor/savesettings.cpp b/lxqt-config-monitor/savesettings.cpp
--- a/lxqt-config-monitor/savesettings.cpp	2025-04-17 10:06:55.000000000 +0100
+++ b/lxqt-config-monitor/savesettings.cpp	2025-05-01 02:30:30.147317761 +0100
@@ -33,7 +33,7 @@
 
     ui.setupUi(this);
 
-    QSize size(128, 64);
+    QSize size(128,64);
     ui.save->setIcon(QIcon::fromTheme("document-save"));
     ui.save->setIconSize(size);
 
@@ -62,9 +62,9 @@
 {
     if( ui.allConfigs->currentItem() == NULL )
         return;
-    QJsonObject obj = ui.allConfigs->currentItem()->data(Qt::UserRole).toJsonObject();
+    QJsonObject obj  = ui.allConfigs->currentItem()->data(Qt::UserRole).toJsonObject();
     applicationSettings->beginGroup("configMonitor");
-    QJsonArray savedConfigs = QJsonDocument::fromJson(applicationSettings->value("saved").toByteArray()).array();
+    QJsonArray  savedConfigs = QJsonDocument::fromJson(applicationSettings->value("saved").toByteArray()).array();
     for(int i=0; i<savedConfigs.size(); i++) {
         const QJsonValue & v = savedConfigs[i];
         QJsonObject o = v.toObject();
@@ -82,13 +82,13 @@
 {
     if( ui.allConfigs->currentItem() == NULL )
         return;
-    QJsonObject obj = ui.allConfigs->currentItem()->data(Qt::UserRole).toJsonObject();
+    QJsonObject obj  = ui.allConfigs->currentItem()->data(Qt::UserRole).toJsonObject();
     bool ok;
     QString configName = QInputDialog::getText(this, tr("Name"), tr("Name:"), QLineEdit::Normal, obj["name"].toString(), &ok);
     if (!ok || configName.isEmpty())
         return;
     applicationSettings->beginGroup("configMonitor");
-    QJsonArray savedConfigs = QJsonDocument::fromJson(applicationSettings->value("saved").toByteArray()).array();
+    QJsonArray  savedConfigs = QJsonDocument::fromJson(applicationSettings->value("saved").toByteArray()).array();
     for(int i=0; i<savedConfigs.size(); i++) {
         const QJsonValue & v = savedConfigs[i];
         QJsonObject o = v.toObject();
@@ -109,7 +109,7 @@
     ui.allConfigs->clear();
     ui.hardwareCompatibleConfigs->clear();
     applicationSettings->beginGroup("configMonitor");
-    QJsonArray savedConfigs = QJsonDocument::fromJson(applicationSettings->value("saved").toByteArray()).array();
+    QJsonArray  savedConfigs = QJsonDocument::fromJson(applicationSettings->value("saved").toByteArray()).array();
     foreach (const QJsonValue & v, savedConfigs) {
         QJsonObject o = v.toObject();
         QListWidgetItem *item = new QListWidgetItem(o["name"].toString(), ui.allConfigs);
diff '--color=auto' -Nur a/src/qcategorizedview/qcategorizedview.cpp b/src/qcategorizedview/qcategorizedview.cpp
--- a/src/qcategorizedview/qcategorizedview.cpp	2025-04-17 10:06:55.000000000 +0100
+++ b/src/qcategorizedview/qcategorizedview.cpp	2025-05-01 02:30:30.147317761 +0100
@@ -443,7 +443,7 @@
                 QModelIndex prevIndex = proxyModel->index(index.row() - 1, q->modelColumn(), q->rootIndex());
                 QRect prevRect = q->visualRect(prevIndex);
                 prevRect = mapFromViewport(prevRect);
-                if ((prevRect.bottomRight().x() + 1) + currSize.width() - blockPos.x() + q->spacing() > viewportW) {
+                if ((prevRect.bottomRight().x() + 1) + currSize.width() - blockPos.x() + q->spacing()  > viewportW) {
                     // we have to check the whole previous row, and see which one was the
                     // highest.
                     Q_FOREVER {
