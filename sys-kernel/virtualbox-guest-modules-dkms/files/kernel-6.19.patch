diff '--color=auto' -Nur a/vboxguest/r0drv/linux/initterm-r0drv-linux.c b/vboxguest/r0drv/linux/initterm-r0drv-linux.c
--- a/vboxguest/r0drv/linux/initterm-r0drv-linux.c	2026-01-28 18:56:00.000000000 +0000
+++ b/vboxguest/r0drv/linux/initterm-r0drv-linux.c	2026-02-26 20:07:42.357171209 +0000
@@ -60,6 +60,11 @@
  * This is a special mm structure used to manage the kernel address space. */
 struct mm_struct *g_pLnxInitMm = NULL;
 
+#if RTLNX_VER_MIN(6,19,0)
+/** Pointer to __flush_tlb_all kernel symbol. */
+void (*g_pfnLinuxFlushTlbAll)(void);
+#endif
+
 
 /**
  * Pushes an item onto the IPRT work queue.
@@ -136,6 +141,11 @@
             printk("rtR0InitNative: g_pLnxInitMm=%p\n", g_pLnxInitMm);
 
             RTR0DbgKrnlInfoRelease(hKrnlInfo);
+# if RTLNX_VER_MIN(6,19,0)
+            g_pfnLinuxFlushTlbAll = __symbol_get("__flush_tlb_all");
+            if (!RT_VALID_PTR(g_pfnLinuxFlushTlbAll))
+                printk("rtR0InitNative: can't load __flush_tlb_all\n");
+# endif
         }
         else
             printk("rtR0InitNative: RTR0DbgKrnlInfoOpen failed: %d\n", rc);
@@ -151,6 +161,12 @@
 {
     IPRT_LINUX_SAVE_EFL_AC();
 
+# if RTLNX_VER_MIN(6,19,0)
+    if (RT_VALID_PTR(g_pfnLinuxFlushTlbAll))
+        symbol_put_addr(g_pfnLinuxFlushTlbAll);
+    g_pfnLinuxFlushTlbAll = NULL;
+#endif
+
     rtR0LnxWorkqueueFlush();
 #if RTLNX_VER_MIN(2,5,41)
     destroy_workqueue(g_prtR0LnxWorkQueue);
diff '--color=auto' -Nur a/vboxguest/r0drv/linux/memobj-r0drv-linux.c b/vboxguest/r0drv/linux/memobj-r0drv-linux.c
--- a/vboxguest/r0drv/linux/memobj-r0drv-linux.c	2026-01-28 18:56:00.000000000 +0000
+++ b/vboxguest/r0drv/linux/memobj-r0drv-linux.c	2026-02-26 20:07:42.357401792 +0000
@@ -2108,6 +2108,17 @@
     return rc;
 }
 
+#if defined(IPRT_USE_ALLOC_VM_AREA_FOR_EXEC) || defined(IPRT_USE_APPLY_TO_PAGE_RANGE_FOR_EXEC)
+static void rtR0MemObjLinuxFlushTlbAll(void)
+{
+# if RTLNX_VER_MIN(6,19,0)
+    if (RT_LIKELY(RT_VALID_PTR(g_pfnLinuxFlushTlbAll)))
+        g_pfnLinuxFlushTlbAll();
+# else
+    __flush_tlb_all();
+# endif
+}
+#endif
 
 DECLHIDDEN(int) rtR0MemObjNativeProtect(PRTR0MEMOBJINTERNAL pMem, size_t offSub, size_t cbSub, uint32_t fProt)
 {
@@ -2128,7 +2139,7 @@
             set_pte(papPtes[i], mk_pte(pMemLnx->apPages[i], fPg));
         }
         preempt_disable();
-        __flush_tlb_all();
+        rtR0MemObjLinuxFlushTlbAll();
         preempt_enable();
         return VINF_SUCCESS;
     }
@@ -2174,7 +2185,7 @@
             flush_icache_range((uintptr_t)pMemLnx->Core.pv + offSub, cbSub);
 #  if defined(RT_ARCH_AMD64) || defined(RT_ARCH_X86) /* flush_tlb_kernel_range is not exported, but __flush_tlb_all is. */
         preempt_disable();
-        __flush_tlb_all();
+        rtR0MemObjLinuxFlushTlbAll();
         preempt_enable();
 #  else
         flush_tlb_kernel_range((uintptr_t)pMemLnx->Core.pv + offSub, cbSub);
diff '--color=auto' -Nur a/vboxguest/r0drv/linux/the-linux-kernel.h b/vboxguest/r0drv/linux/the-linux-kernel.h
--- a/vboxguest/r0drv/linux/the-linux-kernel.h	2026-01-28 18:56:00.000000000 +0000
+++ b/vboxguest/r0drv/linux/the-linux-kernel.h	2026-02-26 20:07:42.357647182 +0000
@@ -512,6 +512,9 @@
 
 
 extern struct mm_struct *g_pLnxInitMm;
+#if RTLNX_VER_MIN(6,19,0)
+extern void (*g_pfnLinuxFlushTlbAll)(void);
+#endif
 
 
 #endif /* !IPRT_INCLUDED_SRC_r0drv_linux_the_linux_kernel_h */
diff '--color=auto' -Nur a/vboxsf/r0drv/linux/the-linux-kernel.h b/vboxsf/r0drv/linux/the-linux-kernel.h
--- a/vboxsf/r0drv/linux/the-linux-kernel.h	2026-01-28 18:56:00.000000000 +0000
+++ b/vboxsf/r0drv/linux/the-linux-kernel.h	2026-02-26 20:07:42.357800389 +0000
@@ -512,6 +512,9 @@
 
 
 extern struct mm_struct *g_pLnxInitMm;
+#if RTLNX_VER_MIN(6,19,0)
+extern void (*g_pfnLinuxFlushTlbAll)(void);
+#endif
 
 
 #endif /* !IPRT_INCLUDED_SRC_r0drv_linux_the_linux_kernel_h */
